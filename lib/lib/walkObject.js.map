{"version":3,"sources":["../../src/lib/walkObject.js"],"names":["isPlainObject","input","Array","isArray","doArrayWalk","key","value","walkArrays","walkArraysMatchingKeys","includes","getPath","pathType","_path","set","parent","nextPath","concat","length","Error","get","makeAttrSetterPath","parts","path","i0","i","_walkObject","object","callback","config","Object","keys","forEach","walkObject"],"mappings":"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","sourcesContent":["export function isPlainObject(input) {\n  return input && !Array.isArray(input) && typeof input === 'object';\n}\n\n/*\n * Helper function for _walkObject\n */\nfunction doArrayWalk(key, value, walkArrays, walkArraysMatchingKeys) {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n\n  if (walkArrays || (walkArraysMatchingKeys && walkArraysMatchingKeys.includes(key))) {\n    return true;\n  }\n\n  return false;\n}\n\n/*\n * Helper utility for path accumulation in _walkObject. Supports array\n * path accumulation and also Plotly.js nestedProperty style.\n */\nfunction getPath(pathType = 'array', _path) {\n  return {\n    _path: _path || (pathType === 'array' ? [] : ''),\n    set(parent, key) {\n      let nextPath;\n      switch (pathType) {\n        case 'array':\n          nextPath = this._path.concat([key]);\n          break;\n\n        case 'nestedProperty':\n          if (this._path.length === 0) {\n            nextPath = key;\n          } else if (Array.isArray(parent)) {\n            nextPath = this._path + `[${key}]`;\n          } else {\n            nextPath = this._path + '.' + key;\n          }\n          break;\n\n        default:\n          throw new Error('unrecognized pathType ' + pathType);\n      }\n\n      return getPath(pathType, nextPath);\n    },\n\n    get(parent, key) {\n      // in array mode we do not return the leaf node key.\n      if (pathType === 'array') {\n        return this._path;\n      }\n\n      // in nestedProperty mode we return full path including final key\n      return this.set(parent, key)._path;\n    },\n  };\n}\n\n/*\n * Helper function that transforms an array of path parts into a single path.\n * For example:\n *\n *  ['_fullData', 0, 'transforms', 3, 'type'] => 'transforms[3].type'\n *\n * Note that it strips out the _fullData part (and also _fullInput) since that's\n * usually present in the attribute path but isn't necessary in the attribute\n * string since it's usually implicitly applied through the userDataIndex.\n */\nexport function makeAttrSetterPath(parts) {\n  let path = '';\n\n  // Truncate the leading parts that aren't intersting when applying changes:\n  let i0 = 0;\n  if (parts[i0] === '_fullData') {\n    i0 += 2;\n  }\n  if (parts[i0] === '_fullInput') {\n    i0++;\n  }\n  if (parts[i0] === '_fullLayout') {\n    i0++;\n  }\n\n  for (let i = i0; i < parts.length; i++) {\n    if (typeof parts[i] === 'number' || Array.isArray(parts[i])) {\n      path += '[' + (Array.isArray(parts[i]) ? parts[i][0] : parts[i]) + ']';\n    } else {\n      path += (i > i0 ? '.' : '') + parts[i];\n    }\n  }\n  return path;\n}\n\n/**\n * The function that walkObject calls at each node.\n *\n * @callback walkObjectCallback\n * @param {string|number} key The current key, which may be nested.\n * @param {object} parent The object which owns the 'key' as a prop.\n * @param {Array} path The keys that lead to the 'parent' object.\n * @returns {boolean} True if the value at 'key' should *not* be traversed into\n *                    if it happens to be an object. I.e., you don't need to\n *                    return anything if you want the default traversal of the\n *                    whole object.\n */\n\n/**\n * Walks through object and recurses if necessary.\n *\n * @param {object} object The top-level or nested object we're walking through.\n * @param {walkObjectCallback} callback Called at each object node.\n * @param {Array} path The keys that lead from to top-level object to this one.\n * @param {object} config configuration object\n * @param {string} config.walkArrays flag allowing array walking\n * @param {Array} config.walkArraysMatchingKeys An array of keys permitting\n *                                              array walking\n * @param {string} config.pathType Either 'array' or 'nestedProperty'. Array\n *                                 based paths return string keys in an array up\n *                                 until the current key position.\n *                                 NestedProperty style returns a single\n *                                 concatenated \"nestedProperty\" style string.\n * @returns {void}\n * @private\n */\nfunction _walkObject(object, callback, path, config) {\n  const {walkArrays, walkArraysMatchingKeys} = config;\n  Object.keys(object).forEach(key => {\n    // Callback can force traversal to stop by returning `true`.\n    if (callback(key, object, path.get(object, key))) {\n      return;\n    }\n\n    const value = object[key];\n    if (isPlainObject(value) || doArrayWalk(key, value, walkArrays, walkArraysMatchingKeys)) {\n      _walkObject(value, callback, path.set(object, key), config);\n    }\n  });\n}\n\n/**\n * General function to walk object and call the given callback for each node.\n *\n * @param {Object|Array} input The object or array we want to walk.\n * @param {walkObjectCallback} callback Called at each object node.\n * @param {Object} [config] configuration object\n * @param {Boolean} [config.walkArrays] flag allowing array walking\n * @param {Array} [config.walkArraysMatchingKeys] An array of keys permitting\n *                                              array walking\n * @param {String} [config.pathType] Either 'array' or 'nestedProperty'. Array\n *                                   based paths return string keys in an array\n *                                   up until the current key position.\n *                                   NestedProperty style returns a single\n *                                   concatenated \"nestedProperty\" style string\n *                                   with the current key included in the path.\n *                                   Defaults to \"array\"\n * @returns {void}\n */\nexport default function walkObject(input, callback, config = {}) {\n  if (!isPlainObject(input) && !Array.isArray(input)) {\n    throw new Error('The input must be an object.');\n  }\n  var path = getPath(config.pathType);\n  _walkObject(input, callback, path, config);\n}\n"],"file":"walkObject.js"}